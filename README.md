# RUST-LRU-CACHE
## 1.1 LRU算法简介
LRU（Least recently used）算法的核心思想为：最近被访问的数据，未来也很有可能被访问，因此保留最近访问的数据，根据数据的历史访问记录来进行淘汰最近没有访问的数据。
## 1.2 LRU实现方法
- 使用哈希表来记录每个数据在双向链表中的位置，实现O(1)的查找速度。
- 链表按照使用顺序存储数据，链表头部的数据是最近访问过的，尾部的数据是最近最久未使用的。
- 为使代码更加简介，使用Unsafe Rust中的裸指针来实现双向链表。
## 2.1 LRU-K算法简介
LRU-K对LRU进行了改进，将“最近使用过1次”的判断标准扩展为“最近使用过K次”。其主要目的是为了解决LRU算法“缓存污染”的问题，也就是说没有到达K次访问的数据并不会被缓存，这也意味着需要对于缓存数据的访问次数进行计数，并且访问记录不能无限记录，也需要使用替换算法进行替换。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。
## 2.2 LRU-K实现方法
- 记录每个数据的访问次数，当访问次数达到k时，表明该数据需要缓存。若历史队列已满，需要根据一定的策略淘汰数据。
- 保存已经访问了k次的数据。若缓存队列已满，需要淘汰掉第k次访问距现在最久的数据。
## 2.3 LRU-K算法流程
以网页缓存为例，算法流程如下：
- 用户发起URL请求。
- 若该URL已在cache中，则直接从cache中获取网页信息，否则从服务器发起请求。
- 将该URL在历史队列中记录的访问次数加一，并将该记录放在历史队列队首。
- 若历史队列已满，则删除历史队列队尾的元素。
- 若该URL在历史队列中的访问次数达到k，则将该网页信息放在缓存队列队首。
- 若缓存队列已满，则删除缓存队列队尾的元素。